/* BEGIN_HEADER */
#include "mbedtls/aria.h"
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_ARIA_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void aria_encrypt_ecb( char *hex_key_string, char *hex_src_string,
                           char *hex_dst_string, int setkey_result )
{
    unsigned char key_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    mbedtls_aria_context ctx;
    int key_len, data_len, i;

    memset( key_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    data_len = unhexify( src_str, hex_src_string );

    TEST_ASSERT( mbedtls_aria_setkey_enc( &ctx, key_str, key_len * 8 ) == setkey_result );
    if( setkey_result == 0 )
    {
        for( i = 0; i < data_len; i += 16 )
        {
            TEST_ASSERT( mbedtls_aria_crypt_ecb( &ctx, MBEDTLS_ARIA_ENCRYPT, src_str + i, output + i ) == 0 );
        }
        hexify( dst_str, output, data_len );

        TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );
    }

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE */
void aria_decrypt_ecb( char *hex_key_string, char *hex_src_string,
                           char *hex_dst_string, int setkey_result )
{
    unsigned char key_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    mbedtls_aria_context ctx;
    int key_len, data_len, i;

    memset(  key_str, 0x00, 1000 );
    memset(  src_str, 0x00, 1000 );
    memset(  dst_str, 0x00, 1000 );
    memset(  output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    data_len = unhexify( src_str, hex_src_string );

    TEST_ASSERT( mbedtls_aria_setkey_dec( &ctx, key_str, key_len * 8 ) == setkey_result );
    if( setkey_result == 0 )
    {
        for( i = 0; i < data_len; i += 16 )
        {
            TEST_ASSERT( mbedtls_aria_crypt_ecb( &ctx, MBEDTLS_ARIA_DECRYPT,
            src_str + i, output + i ) == 0 );
        }
        hexify( dst_str, output, data_len );

        TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );
    }

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CIPHER_MODE_CBC */
void aria_encrypt_cbc( char *hex_key_string, char *hex_iv_string,
                           char *hex_src_string, char *hex_dst_string,
                           int cbc_result )
{
    unsigned char key_str[1000];
    unsigned char iv_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    mbedtls_aria_context ctx;
    int key_len, data_len;

    memset( key_str, 0x00, 1000 );
    memset( iv_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    unhexify( iv_str, hex_iv_string );
    data_len = unhexify( src_str, hex_src_string );

    mbedtls_aria_setkey_enc( &ctx, key_str, key_len * 8 );
    TEST_ASSERT( mbedtls_aria_crypt_cbc( &ctx, MBEDTLS_ARIA_ENCRYPT,
        data_len, iv_str, src_str, output) == cbc_result );
    if( cbc_result == 0 )
    {
        hexify( dst_str, output, data_len );

        TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );
    }

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CIPHER_MODE_CBC */
void aria_decrypt_cbc( char *hex_key_string, char *hex_iv_string,
                           char *hex_src_string, char *hex_dst_string,
                           int cbc_result )
{
    unsigned char key_str[1000];
    unsigned char iv_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    mbedtls_aria_context ctx;
    int key_len, data_len;

    memset( key_str, 0x00, 1000 );
    memset( iv_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    unhexify( iv_str, hex_iv_string );
    data_len = unhexify( src_str, hex_src_string );

    mbedtls_aria_setkey_dec( &ctx, key_str, key_len * 8 );
    TEST_ASSERT( mbedtls_aria_crypt_cbc( &ctx, MBEDTLS_ARIA_DECRYPT,
        data_len, iv_str, src_str, output ) == cbc_result );
    if( cbc_result == 0 )
    {
        hexify( dst_str, output, data_len );

        TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );
    }

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CIPHER_MODE_CFB */
void aria_encrypt_cfb128( char *hex_key_string, char *hex_iv_string,
                              char *hex_src_string, char *hex_dst_string,
                              int result )
{
    unsigned char key_str[1000];
    unsigned char iv_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    mbedtls_aria_context ctx;
    size_t iv_offset = 0;
    int key_len, data_len;

    memset( key_str, 0x00, 1000 );
    memset( iv_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    unhexify( iv_str, hex_iv_string );
    data_len = unhexify( src_str, hex_src_string );

    mbedtls_aria_setkey_enc( &ctx, key_str, key_len * 8 );
    TEST_ASSERT( mbedtls_aria_crypt_cfb128( &ctx, MBEDTLS_ARIA_ENCRYPT,
        data_len, &iv_offset, iv_str, src_str, output ) == result );
    hexify( dst_str, output, data_len );

    TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CIPHER_MODE_CFB */
void aria_decrypt_cfb128( char *hex_key_string, char *hex_iv_string,
                            char *hex_src_string, char *hex_dst_string,
                            int result  )
{
    unsigned char key_str[1000];
    unsigned char iv_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    mbedtls_aria_context ctx;
    size_t iv_offset = 0;
    int key_len, data_len;

    memset( key_str, 0x00, 1000 );
    memset( iv_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    unhexify( iv_str, hex_iv_string );
    data_len = unhexify( src_str, hex_src_string );

    mbedtls_aria_setkey_enc( &ctx, key_str, key_len * 8 );
    TEST_ASSERT( mbedtls_aria_crypt_cfb128( &ctx, MBEDTLS_ARIA_DECRYPT,
        data_len, &iv_offset, iv_str, src_str, output ) == result );
    hexify( dst_str, output, data_len );

    TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CIPHER_MODE_CTR */
void aria_encrypt_ctr( char *hex_key_string, char *hex_iv_string,
                        char *hex_src_string, char *hex_dst_string,
                        int result )
{
    unsigned char key_str[1000];
    unsigned char iv_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    unsigned char blk[16];
    mbedtls_aria_context ctx;
    size_t iv_offset = 0;
    int key_len, data_len;

    memset( key_str, 0x00, 1000 );
    memset( iv_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    unhexify( iv_str, hex_iv_string );
    data_len = unhexify( src_str, hex_src_string );

    mbedtls_aria_setkey_enc( &ctx, key_str, key_len * 8 );
    TEST_ASSERT( mbedtls_aria_crypt_ctr( &ctx, data_len,
        &iv_offset, iv_str, blk, src_str, output ) == result );
    hexify( dst_str, output, data_len );

    TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_CIPHER_MODE_CTR */
void aria_decrypt_ctr( char *hex_key_string, char *hex_iv_string,
                        char *hex_src_string, char *hex_dst_string,
                        int result )
{
    unsigned char key_str[1000];
    unsigned char iv_str[1000];
    unsigned char src_str[1000];
    unsigned char dst_str[1000];
    unsigned char output[1000];
    unsigned char blk[16];
    mbedtls_aria_context ctx;
    size_t iv_offset = 0;
    int key_len, data_len;

    memset( key_str, 0x00, 1000 );
    memset( iv_str, 0x00, 1000 );
    memset( src_str, 0x00, 1000 );
    memset( dst_str, 0x00, 1000 );
    memset( output, 0x00, 1000 );
    mbedtls_aria_init( &ctx );

    key_len = unhexify( key_str, hex_key_string );
    unhexify( iv_str, hex_iv_string );
    data_len = unhexify( src_str, hex_src_string );

    mbedtls_aria_setkey_enc( &ctx, key_str, key_len * 8 );
    TEST_ASSERT( mbedtls_aria_crypt_ctr( &ctx, data_len,
        &iv_offset, iv_str, blk, src_str, output ) == result );
    hexify( dst_str, output, data_len );

    TEST_ASSERT( strcasecmp( (char *) dst_str, hex_dst_string ) == 0 );

exit:
    mbedtls_aria_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SELF_TEST */
void aria_selftest()
{
    TEST_ASSERT( mbedtls_aria_self_test( 1 ) == 0 );
}
/* END_CASE */
